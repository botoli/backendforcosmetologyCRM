// server/index.js - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –°–õ–û–¢–û–í
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const path = require('path');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Database = require('./database/db');
const TelegramBot = require('./telegram/bot');

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
app.use((req, res, next) => {
  console.log('üåê Incoming request:', {
    method: req.method,
    url: req.url,
    origin: req.headers.origin,
    'user-agent': req.headers['user-agent'],
  });
  next();
});

// –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô CORS - —Ä–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ origins –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
app.use(
  cors({
    origin: function (origin, callback) {
      // –†–∞–∑—Ä–µ—à–∞–µ–º –≤—Å–µ origins –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ
      if (!origin) return callback(null, true);

      const allowedOrigins = [
        'http://localhost:3000',
        'http://localhost:3001',
        'http://localhost:5173',
        'http://localhost:5174',
        'http://127.0.0.1:3000',
        'http://127.0.0.1:3001',
        'http://127.0.0.1:5173',
      ];

      if (allowedOrigins.includes(origin)) {
        return callback(null, true);
      } else {
        console.log('CORS blocked for origin:', origin);
        return callback(null, true);
      }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  }),
);

// –û–±—Ä–∞–±–æ—Ç–∫–∞ OPTIONS –∑–∞–ø—Ä–æ—Å–æ–≤
app.options('*', cors());

app.use(express.json());

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
const db = new Database();

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –±–æ—Ç–∞ (–µ—Å–ª–∏ —Ç–æ–∫–µ–Ω —É–∫–∞–∑–∞–Ω)
let bot = null;
if (process.env.TELEGRAM_BOT_TOKEN) {
  try {
    bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, db);
    bot.start();
    console.log('‚úÖ Telegram bot initialized');
  } catch (error) {
    console.error('‚ùå Telegram bot initialization failed:', error.message);
  }
} else {
  console.log('‚ÑπÔ∏è Telegram bot token not provided, bot disabled');
}

// Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ JWT —Ç–æ–∫–µ–Ω–∞
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: '–¢–æ–∫–µ–Ω –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'fallback-secret', (err, decoded) => {
    if (err) {
      return res.status(403).json({ error: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' });
    }

    req.userId = decoded.userId;
    req.user = decoded;
    next();
  });
};

// Health check
app.get('/api/health', (req, res) => {
  console.log('‚úÖ Health check called');
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    database: 'Connected',
    telegramBot: bot ? 'Active' : 'Disabled',
  });
});

// Auth routes
app.post('/api/auth/login', async (req, res) => {
  try {
    const { phoneOrEmail, password } = req.body;

    console.log('üì• Login request:', { phoneOrEmail });

    const user = await db.findUserByPhoneOrEmail(phoneOrEmail);
    if (!user) {
      console.log('‚ùå User not found:', phoneOrEmail);
      return res.status(401).json({
        error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω',
      });
    }

    const isPasswordValid = await bcrypt.compare(password, user.password_hash);
    if (!isPasswordValid) {
      console.log('‚ùå Invalid password for user:', user.email);
      return res.status(401).json({
        error: '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å',
      });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET || 'fallback-secret',
      { expiresIn: '24h' },
    );

    console.log('‚úÖ User logged in successfully:', user.id);

    res.json({
      user: {
        id: user.id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        role: user.role,
        telegramConnected: !!user.telegram_id,
        telegramId: user.telegram_id,
        telegramUsername: user.telegram_username,
      },
      token,
    });
  } catch (error) {
    console.error('‚ùå Login error:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ: ' + error.message,
    });
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { name, surname, phone, email, password } = req.body;

    console.log('üì• Registration request:', { name, surname, phone, email });

    const existingUser = (await db.findUserByEmail(email)) || (await db.findUserByPhone(phone));
    if (existingUser) {
      console.log('‚ùå User already exists:', email);
      return res.status(400).json({
        error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç',
      });
    }

    const passwordHash = await bcrypt.hash(password, 10);

    const user = await db.createUser({
      name,
      surname,
      phone,
      email,
      passwordHash,
      role: 'client',
    });

    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET || 'fallback-secret',
      { expiresIn: '24h' },
    );

    console.log('‚úÖ User registered successfully:', user.id);

    res.json({
      user: {
        id: user.id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        role: user.role,
        telegramConnected: false,
      },
      token,
    });
  } catch (error) {
    console.error('‚ùå Registration error:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏: ' + error.message,
    });
  }
});

// Get current user info
app.get('/api/auth/me', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    console.log('üì• Fetching current user:', userId);

    const user = await db.findUserById(userId);
    if (!user) {
      console.log('‚ùå User not found:', userId);
      return res.status(404).json({
        error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω',
      });
    }

    console.log('‚úÖ Current user fetched:', user.email);

    res.json({
      id: user.id,
      name: user.name,
      surname: user.surname,
      email: user.email,
      phone: user.phone,
      role: user.role,
      telegramConnected: !!user.telegram_id,
      telegramId: user.telegram_id,
      telegramUsername: user.telegram_username,
    });
  } catch (error) {
    console.error('‚ùå Error fetching current user:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è',
      message: error.message,
    });
  }
});

app.post('/api/auth/admin/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    console.log('üì• Admin login request:', { email });

    const user = await db.findUserByEmail(email);
    if (!user || user.role !== 'admin') {
      console.log('‚ùå Admin access denied for:', email);
      return res.status(401).json({
        error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω',
      });
    }

    const isPasswordValid = await bcrypt.compare(password, user.password_hash);
    if (!isPasswordValid) {
      console.log('‚ùå Invalid admin password for:', email);
      return res.status(401).json({
        error: '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å',
      });
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      process.env.JWT_SECRET || 'fallback-secret',
      { expiresIn: '24h' },
    );

    console.log('‚úÖ Admin logged in successfully:', user.id);

    res.json({
      user: {
        id: user.id,
        name: user.name,
        surname: user.surname,
        email: user.email,
        phone: user.phone,
        role: user.role,
        telegramConnected: !!user.telegram_id,
      },
      token,
    });
  } catch (error) {
    console.error('Admin login error:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—Ö–æ–¥–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞',
    });
  }
});

// Services routes
app.get('/api/services', async (req, res) => {
  try {
    console.log('üì• Fetching services from database');
    const services = await db.getServices();
    console.log('‚úÖ Services fetched:', services.length);
    res.json(services);
  } catch (error) {
    console.error('‚ùå Error fetching services:', error);
    res.status(500).json({
      error: 'Failed to fetch services',
      message: error.message,
    });
  }
});

app.post('/api/services', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    const { name, category, description, price, duration } = req.body;
    console.log('üì• Creating service:', { name, category, price });

    const service = await db.createService({
      name,
      category,
      description,
      price,
      duration,
    });

    console.log('‚úÖ Service created:', service.id);
    res.json(service);
  } catch (error) {
    console.error('‚ùå Error creating service:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —É—Å–ª—É–≥–∏',
      message: error.message,
    });
  }
});

app.put('/api/services/:id', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    const { id } = req.params;
    const { name, category, description, price, duration } = req.body;
    console.log('üì• Updating service:', id);

    const service = await db.updateService(id, {
      name,
      category,
      description,
      price,
      duration,
    });

    console.log('‚úÖ Service updated:', id);
    res.json(service);
  } catch (error) {
    console.error('‚ùå Error updating service:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏',
      message: error.message,
    });
  }
});

app.delete('/api/services/:id', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    const { id } = req.params;
    console.log('üì• Deleting service:', id);

    await db.deleteService(id);

    console.log('‚úÖ Service deleted:', id);
    res.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error deleting service:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —É—Å–ª—É–≥–∏',
      message: error.message,
    });
  }
});

// Bookings routes - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –≠–ù–î–ü–û–ò–ù–¢
app.post('/api/bookings', authenticateToken, async (req, res) => {
  try {
    console.log('üì• Creating booking:', req.body);
    const { serviceId, date, time, comment, telegramNotification = true } = req.body;
    const userId = req.userId;

    const booking = await db.createBooking({
      userId,
      serviceId,
      bookingDate: date,
      bookingTime: time,
      comment,
      telegramNotification,
    });

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Å–ª—É–≥–µ –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
    const service = await db.getServiceById(serviceId);
    const user = await db.findUserById(userId);

    console.log('‚úÖ Booking created:', booking.id);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ –∑–∞–ø–∏—Å–∏
    if (bot && user.telegram_id) {
      try {
        await bot.notifyUserAboutBooking(booking, service, user);
        console.log('‚úÖ Telegram notification sent to user:', user.telegram_id);
      } catch (tgError) {
        console.error('‚ùå User Telegram notification failed:', tgError.message);
      }
    } else {
      console.log('‚ÑπÔ∏è User has no Telegram connected, skipping user notification');
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –æ –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏
    if (bot) {
      try {
        await bot.notifyAdminsAboutNewBooking(booking, service, user);
        console.log('‚úÖ Telegram notification sent to admins');
      } catch (tgError) {
        console.error('‚ùå Admin Telegram notification failed:', tgError.message);
      }
    }

    res.json(booking);
  } catch (error) {
    console.error('‚ùå Error creating booking:', error);
    res.status(500).json({
      error: 'Failed to create booking',
      message: error.message,
    });
  }
});

app.get('/api/bookings/my', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    const bookings = await db.getUserBookings(userId);
    res.json(bookings);
  } catch (error) {
    console.error('Error fetching bookings:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–ø–∏—Å–µ–π',
    });
  }
});

app.get('/api/bookings/available-times', authenticateToken, async (req, res) => {
  try {
    const { date, serviceId } = req.query;

    if (!date || !serviceId) {
      return res.status(400).json({
        error: '–î–∞—Ç–∞ –∏ ID —É—Å–ª—É–≥–∏ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã',
      });
    }

    const service = await db.getServiceById(serviceId);
    if (!service) {
      return res.status(404).json({
        error: '–£—Å–ª—É–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞',
      });
    }

    const existingBookings = await db.getBookingsByDate(date);
    const allSlots = generateTimeSlots();
    const bookedSlots = new Set(existingBookings.map((booking) => booking.booking_time));

    const availableSlots = allSlots.filter((slot) => {
      // –ï—Å–ª–∏ —Å–ª–æ—Ç —É–∂–µ –∑–∞–Ω—è—Ç –¥—Ä—É–≥–æ–π –∑–∞–ø–∏—Å—å—é
      if (bookedSlots.has(slot)) return false;

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –∑–∞–ø–∏—Å—è–º–∏
      for (const booking of existingBookings) {
        const bookingTime = booking.booking_time;
        const serviceDuration = booking.service_duration || service.duration || 60;

        // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤—Ä–µ–º—è –ø—Ä–æ—Ü–µ–¥—É—Ä—ã + 30 –º–∏–Ω—É—Ç –¥–ª—è —É–±–æ—Ä–∫–∏/–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏
        const totalBlockedTime = serviceDuration + 30;

        const slotMinutes = timeToMinutes(slot);
        const bookingMinutes = timeToMinutes(bookingTime);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Å–ª–æ—Ç –≤ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
        if (slotMinutes >= bookingMinutes && slotMinutes < bookingMinutes + totalBlockedTime) {
          return false;
        }

        // –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç—Å—è –ª–∏ –Ω–∞—à–∞ –ø—Ä–æ—Ü–µ–¥—É—Ä–∞ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π
        const ourServiceDuration = service.duration || 60;
        if (
          slotMinutes < bookingMinutes + totalBlockedTime &&
          slotMinutes + ourServiceDuration > bookingMinutes
        ) {
          return false;
        }
      }

      return true;
    });

    console.log('‚úÖ Available time slots fetched:', availableSlots.length);
    console.log('üìä Service duration:', service.duration, 'min');
    console.log('üìä Total bookings on date:', existingBookings.length);

    res.json({ availableSlots, allSlots });
  } catch (error) {
    console.error('‚ùå Error fetching available times:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω',
      message: error.message,
    });
  }
});

app.get('/api/bookings/all', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    console.log('üì• Fetching all bookings from database');
    const bookings = await db.getAllBookings();
    console.log('‚úÖ Bookings fetched:', bookings.length);
    res.json(bookings);
  } catch (error) {
    console.error('‚ùå Error fetching bookings:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∑–∞–ø–∏—Å–µ–π',
      message: error.message,
    });
  }
});

app.put('/api/bookings/:id/status', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    const { id } = req.params;
    const { status } = req.body;

    console.log('üì• Updating booking status:', { id, status });

    await db.updateBookingStatus(id, status);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞
    if (bot) {
      try {
        const booking = await db.getBookingById(id);
        if (booking) {
          const user = await db.findUserById(booking.user_id);
          const service = await db.getServiceById(booking.service_id);
          await bot.notifyUserAboutBookingStatus(booking, service, user, status);
          console.log('‚úÖ Status notification sent to user');
        }
      } catch (tgError) {
        console.error('‚ùå Status Telegram notification failed:', tgError.message);
      }
    }

    console.log('‚úÖ Booking status updated successfully');
    res.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error updating booking status:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–ø–∏—Å–∏',
      message: error.message,
    });
  }
});

app.delete('/api/bookings/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.userId;

    console.log('üì• Deleting booking:', id);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    const user = await db.findUserById(userId);
    if (user.role !== 'admin') {
      // –î–ª—è –∫–ª–∏–µ–Ω—Ç–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–ø–∏—Å—å –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
      const booking = await db.getBookingById(id);
      if (!booking || booking.user_id !== userId) {
        return res.status(403).json({
          error: '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏',
        });
      }
    }

    await db.deleteBooking(id);

    console.log('‚úÖ Booking deleted successfully');
    res.json({ success: true });
  } catch (error) {
    console.error('‚ùå Error deleting booking:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∑–∞–ø–∏—Å–∏',
      message: error.message,
    });
  }
});

app.get('/api/clients', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    console.log('üì• Fetching clients from database');
    const clients = await db.getClients();
    console.log('‚úÖ Clients fetched:', clients.length);
    res.json(clients);
  } catch (error) {
    console.error('‚ùå Error fetching clients:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–ª–∏–µ–Ω—Ç–æ–≤',
      message: error.message,
    });
  }
});

app.get('/api/clients/:id', authenticateToken, async (req, res) => {
  try {
    const user = await db.findUserById(req.userId);
    if (user.role !== 'admin') {
      return res.status(403).json({ error: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' });
    }

    const { id } = req.params;
    console.log('üì• Fetching client details:', id);

    const client = await db.getClientDetails(id);
    if (!client) {
      return res.status(404).json({
        error: '–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω',
      });
    }

    console.log('‚úÖ Client details fetched');
    res.json(client);
  } catch (error) {
    console.error('‚ùå Error fetching client details:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –¥–∞–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–∞',
      message: error.message,
    });
  }
});

app.get('/api/schedule', async (req, res) => {
  try {
    const { date } = req.query;
    console.log('üì• Fetching schedule for date:', date);

    const bookings = await db.getAllBookings();
    const dayBookings = bookings.filter((booking) => booking.booking_date === date);

    const schedule = dayBookings.map((booking) => ({
      id: booking.id,
      time: booking.booking_time,
      booked: true,
      client_name: `${booking.user_name} ${booking.user_surname}`,
      service_name: booking.service_name,
    }));

    console.log('‚úÖ Schedule fetched:', schedule.length);
    res.json(schedule);
  } catch (error) {
    console.error('‚ùå Error fetching schedule:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è',
      message: error.message,
    });
  }
});

app.put('/api/schedule/working-hours', async (req, res) => {
  try {
    const workingHours = req.body;
    console.log('üì• Updating working hours:', workingHours);

    console.log('‚úÖ Working hours updated');
    res.json({ success: true, workingHours });
  } catch (error) {
    console.error('‚ùå Error updating working hours:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ä–∞–±–æ—á–∏—Ö —á–∞—Å–æ–≤',
      message: error.message,
    });
  }
});

app.put('/api/schedule/breaks', async (req, res) => {
  try {
    const breaks = req.body;
    console.log('üì• Updating breaks:', breaks);

    console.log('‚úÖ Breaks updated');
    res.json({ success: true, breaks });
  } catch (error) {
    console.error('‚ùå Error updating breaks:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–µ—Ä–µ—Ä—ã–≤–æ–≤',
      message: error.message,
    });
  }
});

// Reports routes
app.post('/api/reports/generate', async (req, res) => {
  try {
    const reportData = req.body;
    console.log('üì• Generating report:', reportData);

    const bookings = await db.getAllBookings();
    const services = await db.getServices();
    const clients = await db.getClients();

    let filteredBookings = bookings;
    if (reportData.startDate && reportData.endDate) {
      filteredBookings = bookings.filter((b) => {
        return b.booking_date >= reportData.startDate && b.booking_date <= reportData.endDate;
      });
    }

    let filteredData = [];
    let stats = {};

    if (reportData.type === 'financial') {
      const completedBookings = filteredBookings.filter((b) => b.status === 'completed');
      const revenue = completedBookings.reduce((sum, b) => sum + (parseFloat(b.price) || 0), 0);
      stats = {
        revenue,
        totalBookings: filteredBookings.length,
        completedBookings: completedBookings.length,
        pendingBookings: filteredBookings.filter((b) => b.status === 'pending').length,
      };
      filteredData = completedBookings;
    } else if (reportData.type === 'bookings') {
      stats = {
        totalBookings: filteredBookings.length,
        completedBookings: filteredBookings.filter((b) => b.status === 'completed').length,
        pendingBookings: filteredBookings.filter((b) => b.status === 'pending').length,
        cancelledBookings: filteredBookings.filter((b) => b.status === 'cancelled').length,
      };
      filteredData = filteredBookings;
    } else if (reportData.type === 'clients') {
      stats = {
        totalClients: clients.length,
      };
      filteredData = clients;
    } else if (reportData.type === 'services') {
      stats = {
        totalServices: services.length,
      };
      filteredData = services;
    }

    const report = {
      id: Date.now(),
      type: reportData.type,
      name: reportData.name,
      data: filteredData,
      stats,
      createdAt: new Date().toISOString(),
    };

    console.log('‚úÖ Report generated successfully');
    res.json({ success: true, report });
  } catch (error) {
    console.error('‚ùå Error generating report:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞',
      message: error.message,
    });
  }
});

app.get('/api/reports/history', async (req, res) => {
  try {
    console.log('üì• Fetching reports history');
    const reports = [];
    console.log('‚úÖ Reports history fetched');
    res.json(reports);
  } catch (error) {
    console.error('‚ùå Error fetching reports history:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏—Å—Ç–æ—Ä–∏–∏ –æ—Ç—á–µ—Ç–æ–≤',
      message: error.message,
    });
  }
});

app.get('/api/reports/:id/download', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üì• Downloading report:', id);
    console.log('‚úÖ Report download initiated');
    res.json({ success: true, message: 'Download not implemented yet' });
  } catch (error) {
    console.error('‚ùå Error downloading report:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞',
      message: error.message,
    });
  }
});

// Telegram routes
app.post('/api/telegram/link', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    const linkCode = Math.random().toString(36).substring(2, 8).toUpperCase();

    await db.createTelegramLink(userId, linkCode);

    console.log('‚úÖ Telegram link created:', linkCode);
    res.json({ linkCode });
  } catch (error) {
    console.error('Error creating telegram link:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å—Å—ã–ª–∫–∏',
    });
  }
});

app.get('/api/telegram/check-link/:code', async (req, res) => {
  try {
    const { code } = req.params;
    console.log('üì• Checking telegram link:', code);

    const link = await db.getTelegramLinkByCode(code);

    if (link && link.is_verified) {
      console.log('‚úÖ Telegram link verified:', code);
      res.json({
        linked: true,
        telegramId: link.telegram_id,
        telegramUsername: link.telegram_username,
      });
    } else {
      console.log('‚ùå Telegram link not verified:', code);
      res.json({ linked: false });
    }
  } catch (error) {
    console.error('Error checking telegram link:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Å—ã–ª–∫–∏',
    });
  }
});

app.post('/api/telegram/unlink', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;
    await db.unlinkTelegram(userId);

    console.log('‚úÖ Telegram unlinked for user:', userId);
    res.json({ success: true });
  } catch (error) {
    console.error('Error unlinking telegram:', error);
    res.status(500).json({
      error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤—è–∑–∫–µ Telegram',
    });
  }
});

// Helper function to generate time slots (every 30 minutes)
const generateTimeSlots = (startHour = 9, endHour = 18) => {
  const slots = [];
  for (let hour = startHour; hour < endHour; hour++) {
    slots.push(`${hour.toString().padStart(2, '0')}:00`);
    slots.push(`${hour.toString().padStart(2, '0')}:30`);
  }
  return slots;
};

// Helper function to convert time string to minutes
const timeToMinutes = (timeStr) => {
  const [hours, minutes] = timeStr.split(':').map(Number);
  return hours * 60 + minutes;
};

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤ API
app.use('/api/*', (req, res) => {
  console.log('‚ùå API endpoint not found:', req.originalUrl);
  res.status(404).json({
    error: 'API endpoint not found',
    path: req.originalUrl,
    method: req.method,
  });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ—Ä–Ω–µ–≤–æ–≥–æ –ø—É—Ç–∏
app.get('/', (req, res) => {
  res.json({
    message: 'Cosmetology API Server',
    endpoints: {
      health: '/api/health',
      auth: '/api/auth/login, /api/auth/register, /api/auth/admin/login',
      services: '/api/services',
      bookings: '/api/bookings, /api/bookings/my, /api/bookings/all, /api/bookings/:id/status',
      clients: '/api/clients, /api/clients/:id',
      schedule: '/api/schedule, /api/schedule/working-hours, /api/schedule/breaks',
      reports: '/api/reports/generate, /api/reports/history, /api/reports/:id/download',
      telegram: '/api/telegram/link, /api/telegram/check-link/:code, /api/telegram/unlink',
    },
  });
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –º–∞—Ä—à—Ä—É—Ç–æ–≤
app.use('*', (req, res) => {
  console.log('‚ùå Route not found:', req.originalUrl);
  res.status(404).json({
    error: 'Route not found',
    path: req.originalUrl,
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`);
  console.log(`üìä Health check: http://localhost:${PORT}/api/health`);
  console.log(`üîë JWT secret: ${process.env.JWT_SECRET ? 'Set' : 'Using fallback'}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nüõë Shutting down server...');
  if (bot) {
    bot.stop();
  }
  db.close();
  process.exit(0);
});
